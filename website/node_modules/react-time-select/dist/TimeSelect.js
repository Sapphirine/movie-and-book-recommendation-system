'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var Input = require('react-bootstrap').Input;
var ReactIntl = require('react-intl');

var HourInput = require('./HourInput');
var MinuteInput = require('./MinuteInput');

var TimePicker = React.createClass({
  displayName: 'TimePicker',

  mixins: [ReactIntl.IntlMixin],

  propTypes: {
    id: React.PropTypes.string,
    className: React.PropTypes.string,
    label: React.PropTypes.string,
    name: React.PropTypes.string,
    value: React.PropTypes.instanceOf(Date),
    start: React.PropTypes.number,
    end: React.PropTypes.number,
    time: React.PropTypes.shape({
      hours: React.PropTypes.string,
      minutes: React.PropTypes.string
    }),
    step: React.PropTypes.number,
    locale: React.PropTypes.string,
    onChange: React.PropTypes.func,
    seperateHourMins: React.PropTypes.bool,
    formats: React.PropTypes.shape({
      time: React.PropTypes.shape({
        short: React.PropTypes.object
      })
    })
  },

  getDefaultProps: function getDefaultProps() {
    return {
      className: 'input-sm',
      label: 'Time',
      name: 'Time',
      // 00:30, 0030 is octal literal 24 & disallowed in strict mode.
      start: 30,
      end: 2359,
      step: 30,
      locale: 'en-GB',
      seperateHourMins: false,
      formats: {
        time: {
          short: {
            hour: '2-digit',
            minute: '2-digit'
          }
        }
      }
    };
  },

  listTimeOptions: function listTimeOptions() {
    var self = this;

    return this.generateTimeRange().map(function (unformattedTime) {
      var formattedTime = self.generateFormattedTime(unformattedTime);

      return {
        key: unformattedTime,
        value: formattedTime,
        date: self.generateDateAtTime(formattedTime)
      };
    });
  },

  generateFormattedTime: function generateFormattedTime(unformattedTime) {
    var formattedTime = '' + unformattedTime;

    while (formattedTime.length < 4) {
      formattedTime = '0' + formattedTime;
    }

    return formattedTime.replace(/(.{2})(.{2})/, '$1:$2');
  },

  generateDateAtTime: function generateDateAtTime(formattedTime) {
    var hoursMins = formattedTime.split(':');
    var newDate = new Date(this.props.value || new Date());
    if (!this.props.seperateHourMins) newDate.setHours(hoursMins[0], hoursMins[1], 0, 0);
    return newDate;
  },

  generateHours: function generateHours() {
    var hours = [];

    for (var hour = 0; hour < 24; hour++) {
      if (hour < 10) {
        hours.push('0' + hour);
      } else {
        hours.push(hour.toString());
      }
    }
    return hours;
  },

  generateMinutes: function generateMinutes() {
    var minutes = [];

    for (var minute = 0; minute <= 60 - this.props.step; minute += this.props.step) {
      if (minute < 10) {
        minutes.push('0' + minute);
      } else {
        minutes.push(minute.toString());
      }
    }

    return minutes;
  },

  generateTimeRange: function generateTimeRange() {
    var times = [];

    var start = parseInt(this.props.start, 10);
    var end = parseInt(this.props.end, 10);
    var step = parseInt(this.props.step, 10);

    for (var i = start; i < end; i += step) {
      var minutes = i % 100;

      if (minutes > 59) {
        i -= minutes;
        i += 100;
      }

      times.push(i);
    }

    return times;
  },

  defaultValueFromProps: function defaultValueFromProps() {
    if (!this.props.value) return undefined;

    return this.generateFormattedTime(this.props.value.getHours() * 100 + this.props.value.getMinutes());
  },

  changeCombinedTime: function changeCombinedTime(e) {
    if (this.props.onChange) {
      var hourMins = e.target.value.split(':');
      this.props.onChange({
        hours: hourMins[0],
        minutes: hourMins[1]
      });
    }
  },

  changeHours: function changeHours(e) {
    this.props.onChange({
      hours: e.target.value,
      minutes: this.props.time.minutes
    });
  },

  changeMinutes: function changeMinutes(e) {
    this.props.onChange({
      hours: this.props.time.hours,
      minutes: e.target.value
    });
  },

  render: function render() {
    var _this = this;

    var timeInput;

    if (this.props.seperateHourMins) {
      timeInput = React.createElement(
        'div',
        { className: 'row' },
        React.createElement(HourInput, {
          id: this.props.id,
          className: this.props.className,
          value: this.props.time.hours,
          name: 'hours',
          onChange: this.changeHours,
          options: this.generateHours() }),
        React.createElement(MinuteInput, {
          id: this.props.id,
          className: this.props.className,
          value: this.props.time.minutes,
          name: 'minutes',
          onChange: this.changeMinutes,
          options: this.generateMinutes() })
      );
    } else {
      timeInput = React.createElement(
        Input,
        {
          type: 'select',
          value: this.defaultValueFromProps(),
          name: this.props.name,
          className: this.props.className,
          label: this.props.label,
          onChange: this.changeCombinedTime,
          id: this.props.id
        },
        this.listTimeOptions().map(function (timeData) {
          return React.createElement(
            ReactIntl.FormattedTime,
            _extends({ key: timeData.key, value: timeData.date }, _this.props.formats.time.short),
            function (time) {
              return React.createElement(
                'option',
                { value: timeData.value },
                time
              );
            }
          );
        })
      );
    }

    return React.createElement(
      ReactIntl.IntlProvider,
      { locale: this.props.locale },
      timeInput
    );
  }
});

module.exports = TimePicker;

